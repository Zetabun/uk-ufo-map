<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>UK UFO / Alien Sightings Map</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <!-- satellite.js (SGP4 propagation) -->
  <script src="https://unpkg.com/satellite.js@5.0.1/dist/satellite.min.js"></script>
<!-- PapaParse (CSV) -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- noUiSlider -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.7.1/dist/nouislider.min.css">
  <script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.1/dist/nouislider.min.js"></script>

  <style>
    :root{
      --bg:#0b0f19;
      --panel:#111827;
      --panel2:#0f172a;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --border:rgba(255,255,255,.08);
      --accent:#60a5fa;
      --danger:#ef4444;
      --ok:#22c55e;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    header{
      display:flex;gap:12px;align-items:center;justify-content:space-between;
      padding:14px 16px;border-bottom:1px solid var(--border);background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0));
      position:sticky;top:0;z-index:10;
    }
    header .left{display:flex;flex-direction:column;gap:2px}
    header h1{font-size:16px;margin:0;letter-spacing:.2px}
    header p{font-size:12px;margin:0;color:var(--muted)}
    header .right{display:flex;gap:8px;align-items:center}
    .btn{
      appearance:none;border:1px solid var(--border);background:rgba(255,255,255,.04);color:var(--text);
      padding:8px 10px;border-radius:10px;cursor:pointer;font-size:12px;
    }
    .btn:hover{background:rgba(255,255,255,.07)}
    .wrap{display:grid;grid-template-columns:360px 1fr;height:calc(100vh - 58px)}
    #panel{
      border-right:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0));
      padding:14px;
      height:calc(100vh - 58px);
      overflow-y:auto;
      overflow-x:hidden;
      min-height:0;
      -webkit-overflow-scrolling:touch;
    }
    #map{height:100%;width:100%}
    .card{background:rgba(17,24,39,.7);border:1px solid var(--border);border-radius:14px;padding:12px;margin-bottom:12px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .row > *{flex:1;min-width:120px}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    input, select{
      width:100%;padding:9px 10px;border-radius:12px;border:1px solid var(--border);
      background:rgba(0,0,0,.25);color:var(--text);outline:none;
    }
    input::placeholder{color:#6b7280}
    .kpis{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .kpi{border:1px solid var(--border);border-radius:14px;padding:10px;background:rgba(0,0,0,.18)}
    .kpi .big{font-size:18px;font-weight:700}
    .kpi .small{font-size:12px;color:var(--muted)}
    .status{font-size:12px;color:var(--muted);display:flex;gap:8px;align-items:center}
    .dot{width:8px;height:8px;border-radius:50%}
    .dot.ok{background:var(--ok)}
    .dot.warn{background:#f59e0b}
    .dot.bad{background:var(--danger)}
    #list{max-height:48vh;overflow:auto;padding-right:4px}
    .item{padding:10px;border:1px solid var(--border);border-radius:14px;background:rgba(0,0,0,.18);margin-bottom:10px;cursor:pointer}
    .item:hover{background:rgba(0,0,0,.28)}
    .item .title{font-weight:650;font-size:13px;margin:0 0 4px 0}
    .item .meta{font-size:12px;color:var(--muted);margin:0}
    .pill{display:inline-block;font-size:11px;padding:3px 8px;border-radius:999px;border:1px solid var(--border);color:var(--muted);margin-right:6px}
    .slider-wrap{padding:6px 2px 2px}
    .slider-meta{display:flex;justify-content:space-between;font-size:12px;color:var(--muted);margin-top:8px}
    .progress{
      height:8px;border-radius:999px;background:rgba(255,255,255,.08);overflow:hidden;border:1px solid var(--border)
    }
    .progress > div{height:100%;width:0;background:linear-gradient(90deg, var(--accent), #a78bfa)}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}
    .hint{font-size:12px;color:var(--muted);line-height:1.35}
    .smallbtn{font-size:11px;padding:6px 8px;border-radius:10px}
	
	/* Make Leaflet popups readable (force light-theme text) */
.leaflet-popup-content-wrapper,
.leaflet-popup-tip {
  background: #ffffff !important;
  color: #111827 !important;
}

.leaflet-popup-content{ color:#111827 !important; }
.leaflet-popup-content *{ color:#111827 !important; }.leaflet-popup-content a {
  color: #1d4ed8 !important;
  text-decoration: underline;
  word-break: break-word;
}

.leaflet-popup-content b,
.leaflet-popup-content strong {
  color: #111827 !important;
}

.leaflet-popup-close-button {
  color: #111827 !important;
}

html, body {
  height: 100%;
  margin: 0;
  overflow: hidden;
}
	
/* Slimmer year-range slider (noUiSlider) */
#yearSlider {
  margin-top: 10px;
  margin-bottom: 6px;
}

#yearSlider .noUi-target {
  border: none;
  box-shadow: none;
  height: 8px;              /* track height */
  border-radius: 999px;
}

#yearSlider .noUi-base,
#yearSlider .noUi-connects {
  height: 8px;
  border-radius: 999px;
}

#yearSlider .noUi-connect {
  border-radius: 999px;
}

#yearSlider .noUi-handle {
  width: 18px;              /* handle size */
  height: 18px;
  right: -9px;              /* keeps it centered */
  top: -5px;                /* vertical align to track */
  border-radius: 999px;
  border: 2px solid rgba(255,255,255,0.35);
  box-shadow: 0 6px 18px rgba(0,0,0,0.25);
}

#yearSlider .noUi-handle:before,
#yearSlider .noUi-handle:after {
  display: none;            /* removes the two little bars */
}

#yearSlider .noUi-touch-area {
  border-radius: 999px;
}
	
	
/* --- Leaflet popup: modern card styling --- */
.leaflet-popup-content-wrapper{
  border-radius: 18px !important;
  padding: 0 !important;
  box-shadow: 0 18px 50px rgba(0,0,0,0.22) !important;
  border: 1px solid rgba(0,0,0,0.08) !important;
}

.leaflet-popup-tip{
  box-shadow: 0 12px 30px rgba(0,0,0,0.18) !important;
}

.leaflet-popup-content{
  margin: 0 !important;
  width: 360px !important;       /* consistent size */
  max-width: 360px !important;
  font-family: inherit;
  color: #111827;
}

/* Scroll inside popup instead of giant bubbles */
.leaflet-popup-content .popup-inner{
  padding: 16px 16px 14px 16px;
  max-height: 70vh;
  overflow: auto;
}

/* Headings + spacing */
.leaflet-popup-content h3{
  margin: 0 0 6px 0;
  font-size: 18px;
  line-height: 1.2;
  letter-spacing: -0.01em;
}

.leaflet-popup-content .popup-date{
  color: #6b7280;
  font-size: 13px;
  margin: 0 0 12px 0;
}

/* Section labels */
.leaflet-popup-content .k{
  font-weight: 700;
}

/* Subtle divider */
.leaflet-popup-content .divider{
  height: 1px;
  background: rgba(0,0,0,0.08);
  margin: 12px 0;
}

/* Nicer source links */
.leaflet-popup-content a{
  color: #1d4ed8;
  text-decoration: none;
}
.leaflet-popup-content a:hover{
  text-decoration: underline;
}

/* Little tag pills */
.leaflet-popup-content .tags{
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin: 8px 0 10px;
}
.leaflet-popup-content .tag{
  display: inline-flex;
  align-items: center;
  padding: 4px 10px;
  font-size: 12px;
  border-radius: 999px;
  background: rgba(0,0,0,0.05);
  border: 1px solid rgba(0,0,0,0.06);
  color: #111827;
}

/* --- Dark dropdowns (select + options) --- */
select, option {
  background: #0b1220;
  color: #e5e7eb;
}

select {
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 14px;
  padding: 10px 12px;
  outline: none;
  box-shadow: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

/* Custom arrow (so it still looks like a dropdown) */
.select-wrap {
  position: relative;
}
.select-wrap::after {
  content: "‚ñæ";
  position: absolute;
  right: 14px;
  top: 50%;
  transform: translateY(-50%);
  pointer-events: none;
  color: rgba(229,231,235,0.8);
  font-size: 14px;
}

/* Hover / focus */
select:hover {
  border-color: rgba(255,255,255,0.22);
}
select:focus {
  border-color: rgba(96,165,250,0.7);
  box-shadow: 0 0 0 4px rgba(96,165,250,0.12);
}


/* --- iOS-style toggles --- */
.toggle-row{display:flex;align-items:center;justify-content:space-between;gap:10px;margin:10px 0}
.toggle-row .label{font-size:12px;color:var(--muted);line-height:1.2}
.switch{position:relative;display:inline-block;width:44px;height:26px;flex:0 0 auto}
.switch input{opacity:0;width:0;height:0}
.slider{
  position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;
  background:rgba(255,255,255,.12);transition:.2s;border-radius:999px;border:1px solid var(--border)
}
.slider:before{
  position:absolute;content:"";height:22px;width:22px;left:2px;top:1px;
  background:white;transition:.2s;border-radius:999px;box-shadow:0 8px 20px rgba(0,0,0,.35)
}
.switch input:checked + .slider{background:rgba(96,165,250,.45);border-color:rgba(96,165,250,.55)}
.switch input:checked + .slider:before{transform:translateX(18px)}
.layer-hint{font-size:12px;color:var(--muted);line-height:1.35;margin-top:6px}


/* --- Astro overlay markers --- */
.astro-pin{
  width:28px;height:28px;border-radius:999px;
  background:rgba(17,24,39,.90);
  border:1px solid rgba(255,255,255,.18);
  display:flex;align-items:center;justify-content:center;
  box-shadow:0 10px 24px rgba(0,0,0,.35);
}


/* --- Debug banner (shows if JS errors happen) --- */
#errorBanner{
  display:none;
  position:fixed;
  left:12px; right:12px; bottom:12px;
  z-index:9999;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(239,68,68,.18);
  color:#fee2e2;
  font-size:12px;
  line-height:1.35;
  backdrop-filter: blur(8px);
}
#errorBanner b{color:#fff}

</style>
</head>

<body>
<header>
  <div class="left">
    <h1>UK UFO / ‚ÄúAlien‚Äù Sightings (Curated)</h1>
    <p>Data source: <strong>Google Sheets (published CSV)</strong> (edit the sheet, refresh the page).</p>
  </div>
  <div class="right">
    <button class="btn" id="fitBtn">Fit to markers</button>
    <button class="btn" id="resetBtn">Reset filters</button>
  </div>
</header>

<div class="wrap">
  <aside id="panel">
    <div class="card">
      <div class="kpis">
        <div class="kpi">
          <div class="big" id="kpiTotal">‚Äî</div>
          <div class="small">Records loaded</div>
        </div>
        <div class="kpi">
          <div class="big" id="kpiShown">‚Äî</div>
          <div class="small">Matching filters</div>
        </div>
      </div>
      <div style="height:10px"></div>
      <div class="status">
        <span class="dot warn" id="statusDot"></span>
        <span id="statusText">Loading cases‚Ä¶</span>
      </div>
      <div style="height:10px"></div>
      <div class="progress" title="Load progress">
        <div id="progBar"></div>
      </div>
      <div style="height:10px"></div>
      <div class="hint">
        Markers plot from <b>lat</b>/<b>lon</b> columns in your Google Sheet. If a row is missing coordinates, the site will try to geocode the <b>Location</b> and cache the result in your browser.
      </div>
    </div>


<div class="card" id="layersCard">
  <div style="font-weight:700;margin-bottom:6px">Map layers</div>

  


<div class="card" id="astroCard">
  <div style="font-weight:700;margin-bottom:6px">Astro overlays</div>

  <div class="toggle-row">
    <div>
      <div style="font-weight:650;font-size:13px">Satellites</div>
      <div class="label">Show track near selected case time (ISS + a few bright satellites)</div>
    </div>
    <label class="switch" title="Toggle satellite overlay">
      <input type="checkbox" id="toggleSat">
      <span class="slider"></span>
    </label>
  </div>

  <div class="toggle-row">
    <div>
      <div style="font-weight:650;font-size:13px">Meteor showers</div>
      <div class="label">Show if a meteor shower was active at the case time</div>
    </div>
    <label class="switch" title="Toggle meteor overlay">
      <input type="checkbox" id="toggleMeteor">
      <span class="slider"></span>
    </label>
  </div>

  <div class="row" style="margin-top:10px">
    <div class="select-wrap" style="flex:1;min-width:160px">
      <label for="satChoice">Satellite set</label>
      <select id="satChoice">
        <option value="iss" selected>ISS (25544)</option>
        <option value="iss_tiangong">ISS + Tiangong</option>
        <option value="iss_tiangong_hst">ISS + Tiangong + Hubble</option>
      </select>
    </div>
    <div style="flex:0 0 auto;min-width:120px;align-self:flex-end">
      <button class="btn smallbtn" id="recalcAstroBtn" type="button">Recalculate</button>
    </div>
  </div>

  <div class="layer-hint" id="astroHint">
    Tip: click a case marker to calculate overlays for that case‚Äôs <b>Date</b>/<b>Time</b> (UK local time, DST-aware).
  </div>
  <div class="hint" id="astroStatus" style="margin-top:8px"></div>
</div>

<div class="toggle-row">
    <div>
      <div style="font-weight:650;font-size:13px">Airports</div>

    <div class="card">
      <div style="font-weight:700;margin-bottom:6px">Make it more interesting (ideas)</div>
      <div class="hint">
        ‚Ä¢ Add a ‚Äúcase page‚Äù route (e.g. <span class="pill">/case/rendlesham</span>) with longer write‚Äëups and images.<br/>
        ‚Ä¢ Add ‚Äúwitness types‚Äù icons and a ‚Äúcase strength‚Äù score breakdown.<br/>
        ‚Ä¢ Add a timeline ‚Äúplay‚Äù mode that animates sightings by year.<br/>
        ‚Ä¢ Add an ‚Äúinvestigation view‚Äù showing MoD/National Archives file references and document thumbnails.
      </div>
    </div>
  </aside>

  <main>
    <div id="map"></div>
  </main>
</div>

<div id="errorBanner"></div>

<script>
(function(){
  window.__ufoError = (msg) => {
    try{
      const b = document.getElementById('errorBanner');
      if(!b) return;
      b.style.display='block';
      b.innerHTML = `<b>Map error:</b> ${String(msg).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[s]))}`;
    }catch(e){}
  };
  window.addEventListener('error', (e) => window.__ufoError(e.message || e.error || 'Unknown error'));
  window.addEventListener('unhandledrejection', (e) => window.__ufoError(e.reason && e.reason.message ? e.reason.message : (e.reason || 'Promise rejected')));

  // ==== CONFIG ====
  // Your published Google Sheets CSV URL (Publish to the web ‚Üí CSV):
  const SHEET_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQ7sia344gHoW613Mc1jQSYR4w_rMv2CcDtc-v1eJrbggnWrdu0FpgRIMMtwCOXULgmoU7UEUHNK-Ib/pub?output=csv';

  const els = {
    statusDot: document.getElementById('statusDot'),
    statusText: document.getElementById('statusText'),
    progBar: document.getElementById('progBar'),
    kpiTotal: document.getElementById('kpiTotal'),
    kpiShown: document.getElementById('kpiShown'),
    region: document.getElementById('region'),
    minCred: document.getElementById('minCred'),
    search: document.getElementById('search'),
    list: document.getElementById('list'),
    fitBtn: document.getElementById('fitBtn'),
    resetBtn: document.getElementById('resetBtn'),
    yearSlider: document.getElementById('yearSlider'),
    yearMin: document.getElementById('yearMin'),
    yearMax: document.getElementById('yearMax'),
    encounter: document.getElementById('encounter'),
    toggleAirports: document.getElementById('toggleAirports'),
    toggleBases: document.getElementById('toggleBases')
,
// Astro overlays
toggleSat: document.getElementById('toggleSat'),
toggleMeteor: document.getElementById('toggleMeteor'),
satChoice: document.getElementById('satChoice'),
recalcAstroBtn: document.getElementById('recalcAstroBtn'),
astroStatus: document.getElementById('astroStatus')
  };

  // Map
  const map = L.map('map', { zoomControl: true }).setView([54.5, -3.0], 6);
  const tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
    maxZoom: 19,
    subdomains: 'abcd',
    attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
  }).addTo(map);
  tileLayer.on('tileerror', () => window.__ufoError('Map tiles failed to load. If you are offline, or a network blocks CARTO tiles, the map will appear blank/blue.'));

  const cluster = L.markerClusterGroup({ showCoverageOnHover: false, maxClusterRadius: 50 });
  map.addLayer(cluster);

  // Optional reference layers
  const airportsLayer = L.layerGroup();
  const basesLayer = L.layerGroup();

// Astro overlays (computed on demand for the selected case)
const satLayer = L.layerGroup();
const meteorLayer = L.layerGroup();

const SAT_SETS = {
  iss: [{ name: "ISS (ZARYA)", norad: 25544 }],
  iss_tiangong: [{ name: "ISS (ZARYA)", norad: 25544 }, { name: "Tiangong", norad: 48274 }],
  iss_tiangong_hst: [{ name: "ISS (ZARYA)", norad: 25544 }, { name: "Tiangong", norad: 48274 }, { name: "Hubble", norad: 20580 }],
};

function makeAstroIcon(emoji){
  return L.divIcon({
    className: '',
    html: `<div class="astro-pin">${emoji}</div>`,
    iconSize: [28, 28],
    iconAnchor: [14, 14]
  });
}

const satIcon = makeAstroIcon("üõ∞Ô∏è");
const meteorIcon = makeAstroIcon("‚òÑÔ∏è");

// UK time (Europe/London) => UTC timestamp. Handles DST without external libs.
function ukLocalToUtcMs(dateStr, timeStr){
  if(!dateStr) return null;
  const t = (String(timeStr||'').trim() || '12:00').slice(0,5);
  const isoLocal = `${String(dateStr).trim()}T${t}:00`;
  const assumed = new Date(isoLocal + 'Z');

  const parts = new Intl.DateTimeFormat('en-GB', {
    timeZone: 'Europe/London',
    year:'numeric',month:'2-digit',day:'2-digit',
    hour:'2-digit',minute:'2-digit',second:'2-digit',
    hour12:false
  }).formatToParts(assumed).reduce((acc,p)=>{acc[p.type]=p.value; return acc;},{});

  const desiredWall = new Date(`${dateStr}T${t}:00Z`);
  const actualWall = new Date(`${parts.year}-${parts.month}-${parts.day}T${parts.hour}:${parts.minute}:${parts.second}Z`);
  const deltaMs = desiredWall.getTime() - actualWall.getTime();
  return assumed.getTime() + deltaMs;
}

function fmtUtcMs(ms){
  const d = new Date(ms);
  return d.toISOString().replace('T',' ').slice(0,19) + 'Z';
}

async function fetchNearestTle(norad, eventUtcMs){
  const d = new Date(eventUtcMs);
  const y = d.getUTCFullYear();
  const mo = String(d.getUTCMonth()+1).padStart(2,'0');
  const da = String(d.getUTCDate()).padStart(2,'0');

  const start = `${y}${mo}${da}T0000`;
  const endDate = new Date(Date.UTC(y, d.getUTCMonth(), d.getUTCDate()+1));
  const y2 = endDate.getUTCFullYear();
  const m2 = String(endDate.getUTCMonth()+1).padStart(2,'0');
  const d2 = String(endDate.getUTCDate()).padStart(2,'0');
  const end = `${y2}${m2}${d2}T0000`;

  const url = `https://satdb.ethz.ch/api/satellitedata/?norad-id=${encodeURIComponent(norad)}&start-datetime=${start}&end-datetime=${end}&before=10&after=10&without-frequency-data=True`;

  const res = await fetch(url, { headers: { 'Accept':'application/json' } });
  if(!res.ok) throw new Error(`satdb HTTP ${res.status}`);
  const js = await res.json();

  const all = [];
  for(const item of (js.results||[])){
    if(item && item.norad_str) all.push(item.norad_str);
  }
  let next = js.next;
  while(next){
    const r2 = await fetch(next, { headers: { 'Accept':'application/json' } });
    if(!r2.ok) break;
    const j2 = await r2.json();
    for(const item of (j2.results||[])){
      if(item && item.norad_str) all.push(item.norad_str);
    }
    next = j2.next;
  }
  if(!all.length) return null;

  function tleEpochToMs(line1){
    const m = String(line1).match(/\s(\d{2})(\d{3}\.\d+)/);
    if(!m) return null;
    const yy = parseInt(m[1],10);
    const year = (yy < 57) ? 2000+yy : 1900+yy;
    const dayOfYear = parseFloat(m[2]);
    const dayInt = Math.floor(dayOfYear);
    const frac = dayOfYear - dayInt;
    const startYear = Date.UTC(year,0,1,0,0,0);
    return startYear + (dayInt-1)*86400000 + Math.round(frac*86400000);
  }

  let best = null;
  let bestDiff = Infinity;
  for(const tleStr of all){
    const lines = tleStr.trim().split(/\r?\n/).filter(Boolean);
    const l1 = lines.find(x=>x.trim().startsWith('1 '));
    const l2 = lines.find(x=>x.trim().startsWith('2 '));
    if(!l1 || !l2) continue;
    const ep = tleEpochToMs(l1);
    if(!ep) continue;
    const diff = Math.abs(ep - eventUtcMs);
    if(diff < bestDiff){
      bestDiff = diff;
      best = { line1: l1.trim(), line2: l2.trim(), epochMs: ep };
    }
  }
  return best;
}

function groundTrackFromTle(tle, startUtcMs, endUtcMs, stepSec=30){
  const satrec = satellite.twoline2satrec(tle.line1, tle.line2);
  const pts = [];
  for(let t = startUtcMs; t <= endUtcMs; t += stepSec*1000){
    const date = new Date(t);
    const pv = satellite.propagate(satrec, date);
    if(!pv.position) continue;
    const gmst = satellite.gstime(date);
    const geo = satellite.eciToGeodetic(pv.position, gmst);
    const lat = satellite.degreesLat(geo.latitude);
    const lon = satellite.degreesLong(geo.longitude);
    const lonNorm = ((lon + 540) % 360) - 180;
    pts.push([lat, lonNorm, t]);
  }
  return pts;
}

// Major annual showers (approximate activity windows; individual years vary).
const METEOR_SHOWERS = [
  { name: "Quadrantids", start: "01-01", end: "01-12", peak: "01-03" },
  { name: "Lyrids", start: "04-16", end: "04-25", peak: "04-22" },
  { name: "Eta Aquariids", start: "04-19", end: "05-28", peak: "05-06" },
  { name: "Delta Aquariids", start: "07-12", end: "08-23", peak: "07-30" },
  { name: "Perseids", start: "07-17", end: "08-24", peak: "08-12" },
  { name: "Draconids", start: "10-06", end: "10-10", peak: "10-08" },
  { name: "Orionids", start: "10-02", end: "11-07", peak: "10-21" },
  { name: "Leonids", start: "11-06", end: "11-30", peak: "11-17" },
  { name: "Geminids", start: "12-04", end: "12-17", peak: "12-14" },
  { name: "Ursids", start: "12-17", end: "12-26", peak: "12-22" },
];

function mmddToDayOfYear(year, mmdd){
  const [mm, dd] = mmdd.split('-').map(x=>parseInt(x,10));
  const d = new Date(Date.UTC(year, mm-1, dd, 0,0,0));
  const start = new Date(Date.UTC(year,0,1,0,0,0));
  return Math.floor((d - start) / 86400000) + 1;
}

function activeMeteorShowers(dateUtc){
  const y = dateUtc.getUTCFullYear();
  const doy = Math.floor((dateUtc - new Date(Date.UTC(y,0,1))) / 86400000) + 1;
  const active = [];
  for(const s of METEOR_SHOWERS){
    const s0 = mmddToDayOfYear(y, s.start);
    const s1 = mmddToDayOfYear(y, s.end);
    const inRange = (s0 <= s1) ? (doy >= s0 && doy <= s1) : (doy >= s0 || doy <= s1);
    if(inRange) active.push(s);
  }
  return active;
}

let selectedRecord = null;

function syncAstroToggles(){
  if(els.toggleSat){
    if(els.toggleSat.checked) satLayer.addTo(map);
    else map.removeLayer(satLayer);
  }
  if(els.toggleMeteor){
    if(els.toggleMeteor.checked) meteorLayer.addTo(map);
    else map.removeLayer(meteorLayer);
  }
}

async function recalcAstroForSelected(){
  if(!els.astroStatus) return;
  if(!selectedRecord){
    els.astroStatus.textContent = 'Select a case first (click a marker).';
    return;
  }

  const wantSat = !!(els.toggleSat && els.toggleSat.checked);
  const wantMet = !!(els.toggleMeteor && els.toggleMeteor.checked);

  satLayer.clearLayers();
  meteorLayer.clearLayers();
  syncAstroToggles();

  if(!wantSat && !wantMet){
    els.astroStatus.textContent = 'Astro overlays are off.';
    return;
  }

  if(!Number.isFinite(selectedRecord.lat) || !Number.isFinite(selectedRecord.lon)){
    els.astroStatus.textContent = 'This case has no coordinates (can‚Äôt compute overlays).';
    return;
  }

  const dateIso = String(selectedRecord.date_iso || '').trim();
  const dateStr = String(selectedRecord.date || '').trim();
  const timeStr = String(selectedRecord.time || '').trim() || '12:00';

  let ymd = null;
  let hm = null;

  const mIso = dateIso.match(/^(\d{4}-\d{2}-\d{2})(?:[ T](\d{2}:\d{2}))?/);
  if(mIso){
    ymd = mIso[1];
    hm = mIso[2] || timeStr;
  } else {
    const mDate = dateStr.match(/(\d{4}-\d{2}-\d{2})/);
    if(mDate){
      ymd = mDate[1];
      hm = timeStr;
    }
  }

  if(!ymd){
    els.astroStatus.textContent = 'Date format not recognised (expected YYYY-MM-DD).';
    return;
  }

  const utcMs = ukLocalToUtcMs(ymd, hm);
  if(utcMs == null){
    els.astroStatus.textContent = 'Could not convert UK time to UTC for this case.';
    return;
  }
  const utc = new Date(utcMs);

  const statusLines = [];
  statusLines.push(`Selected: ${selectedRecord.case || 'case'} ‚Ä¢ ${fmtUtcMs(utcMs)} (from UK local time)`);

  if(wantMet){
    const active = activeMeteorShowers(utc);
    const txt = active.length ? active.map(s => `${s.name} (peak ~${s.peak})`).join(', ') : 'None of the major annual showers';
    statusLines.push(`Meteor showers: ${txt}`);

    L.marker([selectedRecord.lat, selectedRecord.lon], { icon: meteorIcon, title: 'Meteor context' })
      .bindPopup(`
        <div class="popup-inner">
          <h3>Meteor context</h3>
          <p class="popup-date">${escapeHtml(selectedRecord.date || '')}${selectedRecord.time ? ` ‚Ä¢ ${escapeHtml(selectedRecord.time)}` : ''}</p>
          <div class="tags"><span class="tag">Meteor showers</span></div>
          <div style="font-size:13px;line-height:1.45">
            <div><span class="k">Active showers:</span> ${escapeHtml(txt)}</div>
            <div style="margin-top:10px;color:#6b7280">Note: shower activity windows are approximate; individual years vary. Sporadic meteors can still occur any night.</div>
          </div>
        </div>
      `, { maxWidth: 420 })
      .addTo(meteorLayer);
  }

  if(wantSat){
    const choice = (els.satChoice && els.satChoice.value) ? els.satChoice.value : 'iss';
    const sats = SAT_SETS[choice] || SAT_SETS.iss;

    const windowMin = 30;
    const startMs = utcMs - windowMin*60*1000;
    const endMs = utcMs + windowMin*60*1000;

    for(const s of sats){
      try{
        const tle = await fetchNearestTle(s.norad, utcMs);
        if(!tle){
          statusLines.push(`${s.name}: no TLE found for that date.`);
          continue;
        }
        const track = groundTrackFromTle(tle, startMs, endMs, 30);
        if(track.length < 2){
          statusLines.push(`${s.name}: could not compute track.`);
          continue;
        }

        const latlngs = track.map(p => [p[0], p[1]]);
        L.polyline(latlngs, { weight: 3, opacity: 0.85 }).addTo(satLayer);

        let best = track[0];
        let bestDiff = Infinity;
        for(const p of track){
          const diff = Math.abs(p[2] - utcMs);
          if(diff < bestDiff){
            bestDiff = diff;
            best = p;
          }
        }

        L.marker([best[0], best[1]], { icon: satIcon, title: s.name })
          .bindPopup(`
            <div class="popup-inner">
              <h3>${escapeHtml(s.name)}</h3>
              <p class="popup-date">${fmtUtcMs(utcMs)}</p>
              <div class="tags"><span class="tag">Satellite track</span></div>
              <div style="font-size:13px;line-height:1.45">
                <div><span class="k">NORAD:</span> ${escapeHtml(String(s.norad))}</div>
                <div style="margin-top:8px"><span class="k">Position at case time:</span> ${best[0].toFixed(3)}, ${best[1].toFixed(3)}</div>
                <div style="margin-top:8px;color:#6b7280">Track shown for ¬±${windowMin} minutes around the case time.</div>
                <div style="margin-top:8px;color:#6b7280">TLE epoch used: ${fmtUtcMs(tle.epochMs)} (nearest available)</div>
              </div>
            </div>
          `, { maxWidth: 420 })
          .addTo(satLayer);

        statusLines.push(`${s.name}: track computed (TLE epoch ${fmtUtcMs(tle.epochMs)}).`);
      } catch(e){
        console.warn('Satellite overlay failed:', s, e);
        statusLines.push(`${s.name}: error (${e && e.message ? e.message : e}).`);
      }
    }
  }

  els.astroStatus.innerHTML = statusLines.map(s => `<div class="hint">${escapeHtml(s)}</div>`).join('');
  syncAstroToggles();
}


  // Minimal curated sets (major airports + key bases). You can add/remove items anytime.
  const AIRPORTS = [
    { name: "London Heathrow (LHR)", lat: 51.4700, lon: -0.4543 },
    { name: "London Gatwick (LGW)", lat: 51.1537, lon: -0.1821 },
    { name: "London Stansted (STN)", lat: 51.8850, lon: 0.2350 },
    { name: "London Luton (LTN)", lat: 51.8747, lon: -0.3683 },
    { name: "London City (LCY)", lat: 51.5053, lon: 0.0553 },
    { name: "Manchester (MAN)", lat: 53.3537, lon: -2.2750 },
    { name: "Birmingham (BHX)", lat: 52.4539, lon: -1.7480 },
    { name: "Bristol (BRS)", lat: 51.3827, lon: -2.7191 },
    { name: "Liverpool John Lennon (LPL)", lat: 53.3336, lon: -2.8497 },
    { name: "Newcastle (NCL)", lat: 55.0375, lon: -1.6917 },
    { name: "Leeds Bradford (LBA)", lat: 53.8659, lon: -1.6606 },
    { name: "Edinburgh (EDI)", lat: 55.9500, lon: -3.3725 },
    { name: "Glasgow (GLA)", lat: 55.8719, lon: -4.4331 },
    { name: "Aberdeen (ABZ)", lat: 57.2019, lon: -2.1978 },
    { name: "Belfast International (BFS)", lat: 54.6575, lon: -6.2158 },
    { name: "Cardiff (CWL)", lat: 51.3967, lon: -3.3433 }
  ];

  const BASES = [
    { name: "RAF Brize Norton", lat: 51.7500, lon: -1.5830 },
    { name: "RAF Fairford", lat: 51.6820, lon: -1.7900 },
    { name: "RAF Lakenheath", lat: 52.4090, lon: 0.5610 },
    { name: "RAF Mildenhall", lat: 52.3610, lon: 0.4860 },
    { name: "RAF Coningsby", lat: 53.0930, lon: -0.1660 },
    { name: "RAF Marham", lat: 52.6500, lon: 0.5500 },
    { name: "RAF Lossiemouth", lat: 57.7050, lon: -3.3390 },
    { name: "RAF Leeming", lat: 54.2950, lon: -1.5330 },
    { name: "RAF Valley (Anglesey)", lat: 53.2520, lon: -4.5350 },
    { name: "RAF Shawbury", lat: 52.7980, lon: -2.6680 },
    { name: "RAF Waddington", lat: 53.1670, lon: -0.5240 },
    { name: "Army: Salisbury Plain Training Area", lat: 51.2000, lon: -1.8000 },
    { name: "HMNB Portsmouth", lat: 50.8010, lon: -1.1100 },
    { name: "HMNB Clyde (Faslane)", lat: 56.0520, lon: -4.8250 },
    { name: "Cawdor Barracks (Brawdy, Pembrokeshire)", lat: 51.8770, lon: -5.1230 },
    { name: "MOD St Athan", lat: 51.4040, lon: -3.4350 }
  ];

  function makePoiIcon(emoji){
    return L.divIcon({
      className: '',
      html: `<div style="width:26px;height:26px;border-radius:999px;background:rgba(17,24,39,.85);border:1px solid rgba(255,255,255,.18);display:flex;align-items:center;justify-content:center;box-shadow:0 10px 24px rgba(0,0,0,.35)">${emoji}</div>`,
      iconSize: [26, 26],
      iconAnchor: [13, 13]
    });
  }

  const airportIcon = makePoiIcon("‚úàÔ∏è");
  const baseIcon = makePoiIcon("üõ°Ô∏è");

  function buildPoiLayers(){
    airportsLayer.clearLayers();
    basesLayer.clearLayers();

    const esc = (str) => String(str ?? '').replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));

    AIRPORTS.forEach(a => {
      L.marker([a.lat, a.lon], { icon: airportIcon, title: a.name })
        .bindPopup(`
          <div class="popup-inner">
            <h3>${esc(a.name)}</h3>
            <div class="tags">
              <span class="tag">Airport</span>
            </div>
            <div style="font-size:13px;line-height:1.45">
              <div><span class="k">Coordinates:</span> ${a.lat.toFixed(4)}, ${a.lon.toFixed(4)}</div>
              <div style="margin-top:10px">
                <a href="https://www.google.com/maps?q=${a.lat},${a.lon}" target="_blank" rel="noopener">Open in Google Maps</a>
              </div>
            </div>
          </div>
        `, { maxWidth: 420 })
        .addTo(airportsLayer);
    });

BASES.forEach(b => {
      L.marker([b.lat, b.lon], { icon: baseIcon, title: b.name })
        .bindPopup(`
          <div class="popup-inner">
            <h3>${esc(b.name)}</h3>
            <div class="tags">
              <span class="tag">Military base</span>
            </div>
            <div style="font-size:13px;line-height:1.45">
              <div><span class="k">Coordinates:</span> ${b.lat.toFixed(4)}, ${b.lon.toFixed(4)}</div>
              <div style="margin-top:10px">
                <a href="https://www.google.com/maps?q=${b.lat},${b.lon}" target="_blank" rel="noopener">Open in Google Maps</a>
              </div>
            </div>
          </div>
        `, { maxWidth: 420 })
        .addTo(basesLayer);
    });
}

  buildPoiLayers();

  // Fix occasional "map misalignment" (Leaflet needs a resize invalidate after layout settles)
  function fixMapSizeSoon(){
    setTimeout(() => { try { map.invalidateSize(true); } catch(e){} }, 50);
    setTimeout(() => { try { map.invalidateSize(true); } catch(e){} }, 300);
    setTimeout(() => { try { map.invalidateSize(true); } catch(e){} }, 900);
  }
  window.addEventListener('resize', () => fixMapSizeSoon());


  // State
  let records = [];
  let markersById = new Map();
  let currentYearMin = 1900, currentYearMax = 2100;

  // UK-ish bounds (used to detect swapped coordinates / bad geocodes)
  const UK_SOFT_BOUNDS = { minLat: 45.0, maxLat: 65.0, minLon: -12.0, maxLon: 6.0 };

  function isWithinBounds(lat, lon, b){
    return Number.isFinite(lat) && Number.isFinite(lon) &&
           lat >= b.minLat && lat <= b.maxLat && lon >= b.minLon && lon <= b.maxLon;
  }

  // If a row has lat/lon swapped (common), detect and fix it.
  function normaliseCoords(lat, lon){
    const la = Number(lat), lo = Number(lon);
    if(!Number.isFinite(la) || !Number.isFinite(lo)) return { lat: la, lon: lo, fixed: false };

    // Correct if it looks swapped: lat is UK-ish longitude range and lon is UK-ish latitude range
    if(la >= UK_SOFT_BOUNDS.minLon && la <= UK_SOFT_BOUNDS.maxLon &&
       lo >= UK_SOFT_BOUNDS.minLat && lo <= UK_SOFT_BOUNDS.maxLat){
      return { lat: lo, lon: la, fixed: true };
    }
    return { lat: la, lon: lo, fixed: false };
  }

  function setStatus(type, text){
    els.statusDot.classList.remove('ok','warn','bad');
    els.statusDot.classList.add(type);
    els.statusText.textContent = text;
  }
  function setProgress(done, total){
    const pct = total ? Math.round((done/total)*100) : 0;
    els.progBar.style.width = pct + '%';
  }

  function safeYear(dateStr){
    if(!dateStr) return null;
    const m = String(dateStr).match(/\b(18\d{2}|19\d{2}|20\d{2})\b/);
    return m ? parseInt(m[1],10) : null;
  }

  function parseSources(src){
    if(!src) return [];
    return String(src).split(/[\n;]+/).map(s=>s.trim()).filter(Boolean);
  }

  function parseVideos(v){
    if(!v) return [];
    return String(v).split(/[\n;]+/).map(s=>s.trim()).filter(Boolean);
  }


  
  // Case-insensitive, trimmed header lookup (handles 'Weather ', 'weather summary', etc.)
  function getField(row, names){
    if(!row) return '';
    const keys = Object.keys(row);
    for(const n of names){
      const target = String(n).trim().toLowerCase();
      // direct
      for(const k of keys){
        if(String(k).trim().toLowerCase() === target){
          return row[k];
        }
      }
    }
    return '';
  }

function escapeHtml(str){
    return String(str ?? '').replace(/[&<>"']/g, s => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[s]));
  }

    function makePopupHTML(r){
    const sources = parseSources(r.sources);
    const videos = parseVideos(r.videos);

    const sourcesBlock = sources.length
      ? `<div style="font-weight:800;margin-bottom:6px">Sources</div>
         ${sources.map((u,i) => {
            const label = `Source ${i+1}`;
            return `<div style="margin:4px 0">
                      <a href="${escapeHtml(u)}" target="_blank" rel="noopener">${label}</a>
                    </div>`;
          }).join('')}`
      : '';

    const videosBlock = videos.length
      ? `<div style="font-weight:800;margin-bottom:6px">Videos</div>
         ${videos.map((u,i) => {
            const label = `Video ${i+1}`;
            return `<div style="margin:4px 0">
                      <a href="${escapeHtml(u)}" target="_blank" rel="noopener">${label}</a>
                    </div>`;
          }).join('')}`
      : '';

    let linksHtml = '';
    if(sources.length || videos.length){
      if(sources.length && videos.length){
        linksHtml = `<div class="divider"></div>
          <div style="display:flex;gap:14px;align-items:flex-start">
            <div style="flex:1;min-width:0">${sourcesBlock}</div>
            <div style="flex:1;min-width:0">${videosBlock}</div>
          </div>`;
      }else if(sources.length){
        linksHtml = `<div class="divider"></div>${sourcesBlock}`;
      }else{
        linksHtml = `<div class="divider"></div>${videosBlock}`;
      }
    }

    const tags = `
      <div class="tags">
        <span class="tag">${escapeHtml(r.region || '‚Äî')}</span>
        <span class="tag">Credibility: ${escapeHtml(String(r.cred || '‚Äî'))}</span>
        ${r.status ? `<span class="tag">${escapeHtml(r.status)}</span>` : ''}
        ${(() => {
          const raw = String(r.encounter || '').trim().toLowerCase();
          const isYes = ['yes','y','true','1'].includes(raw);
          const enc = raw ? (isYes ? 'Yes' : 'No') : 'No';
          return `<span class="tag">Encounter: ${enc}</span>`;
        })()}
      </div>`;

    const weatherBlock = (r.weather && String(r.weather).trim())
      ? `<div style="margin:10px 0 12px;padding:10px 12px;border:1px solid rgba(0,0,0,.08);border-radius:14px;background:#f9fafb">
           <div style="font-weight:800;margin-bottom:6px">Weather</div>
           <div style="font-size:13px;line-height:1.35">${escapeHtml(r.weather)}</div>
           ${r.weather_source ? `<div style="font-size:11px;color:#6b7280;margin-top:6px">Source: ${escapeHtml(r.weather_source)}</div>` : ''}
         </div>`
      : '';

    return `
      <div class="popup-inner">
        <h3>${escapeHtml(r.case)}</h3>
        <p class="popup-date">${escapeHtml(r.date || '')}${r.time ? ` ‚Ä¢ ${escapeHtml(r.time)}` : ''}</p>
        ${tags}
        ${weatherBlock}
        <div style="font-size:13px;line-height:1.45">
          <div><span class="k">Location:</span> ${escapeHtml(r.location || '‚Äî')}</div>
          <div style="margin-top:8px"><span class="k">Witness:</span> ${escapeHtml(r.witness || '‚Äî')}</div>
          <div style="margin-top:8px"><span class="k">Evidence:</span> ${escapeHtml(r.evidence || '‚Äî')}</div>
          ${r.summary ? `<div style="margin-top:10px">${escapeHtml(r.summary)}</div>` : ''}
          ${r.why ? `<div style="margin-top:10px;color:#6b7280">${escapeHtml(r.why)}</div>` : ''}
          ${linksHtml}
        </div>
      </div>
    `;
  }

  function markerColorByCred(cred){
    const c = Number(cred || 0);
    if(c >= 4) return '#22c55e';
    if(c >= 3) return '#60a5fa';
    return '#f59e0b';
  }

  function makeCircleMarker(lat, lon, cred){
    const color = markerColorByCred(cred);
    return L.circleMarker([lat, lon], {
      radius: 7,
      weight: 2,
      color: color,
      fillColor: color,
      fillOpacity: 0.25
    });
  }

  function clearMarkers(){
    cluster.clearLayers();
    markersById.clear();
  }

  function matchesFilters(r){
    const q = (els.search ? els.search.value : '').trim().toLowerCase();
    const reg = els.region ? els.region.value : '';
    const minCred = parseInt(els.minCred ? els.minCred.value : '1', 10);
    const y = r.year || 0;
    const enc = (els.encounter && els.encounter.value) ? els.encounter.value : '';

    if(q){
      const hay = [r.case,r.location,r.region,r.summary,r.witness,r.evidence,r.status,r.weather].join(' ').toLowerCase();
      if(!hay.includes(q)) return false;
    }
    if(reg && (r.region || '') !== reg) return false;
    if((r.cred || 0) < minCred) return false;
    if(y && (y < currentYearMin || y > currentYearMax)) return false;

    if(enc){
      const raw = String(r.encounter || '').trim().toLowerCase();
      const isYes = ['yes','y','true','1'].includes(raw);
      const rowEnc = raw ? (isYes ? 'yes' : 'no') : 'no';
      if(rowEnc !== enc) return false;
    }

    return true;
  }

  function render(){
    clearMarkers();
    els.list.innerHTML = '';

    const shown = records.filter(matchesFilters);
    els.kpiShown.textContent = shown.length;

    for(const r of shown){
      if(!Number.isFinite(r.lat) || !Number.isFinite(r.lon)) continue;
      const m = makeCircleMarker(r.lat, r.lon, r.cred);
      m.bindPopup(makePopupHTML(r), { maxWidth: 420 });
      m.on('click', () => highlightListItem(r.id));
      m.on('popupopen', () => { selectedRecord = r; if((els.toggleSat && els.toggleSat.checked) || (els.toggleMeteor && els.toggleMeteor.checked)) recalcAstroForSelected(); });
      cluster.addLayer(m);
      markersById.set(r.id, m);
    }

    for(const r of shown.slice(0, 250)){
      const div = document.createElement('div');
      div.className = 'item';
      div.dataset.id = r.id;
      div.innerHTML = `
        <p class="title">${escapeHtml(r.case)}</p>
        <p class="meta">${escapeHtml(r.location)} ‚Ä¢ ${escapeHtml(r.date || '')}</p>
        ${r.weather ? `<p class="meta" style="margin-top:6px; color:#6b7280">Weather: ${escapeHtml(r.weather).slice(0, 90)}${(String(r.weather).length>90?'‚Ä¶':'')}</p>` : ''}
        <div style="margin-top:8px">
          <span class="pill">${escapeHtml(r.region || '‚Äî')}</span>
          <span class="pill">Cred: ${escapeHtml(String(r.cred || '‚Äî'))}</span>
          <span class="pill">${escapeHtml(r.status || '‚Äî')}</span>
        </div>
      `;
      div.addEventListener('click', () => {
        const mk = markersById.get(r.id);
        if(mk){
          map.setView(mk.getLatLng(), Math.max(map.getZoom(), 9));
          selectedRecord = r;
          mk.openPopup();
        }
      });
      els.list.appendChild(div);
    }

    if(shown.length === 0){
      const empty = document.createElement('div');
      empty.className = 'hint';
      empty.textContent = 'No results match your filters.';
      els.list.appendChild(empty);
    }
  }

function highlightListItem(id){
  const el = els.list.querySelector(`.item[data-id="${id}"]`);
  if(!el) return;

  // Scroll ONLY inside the results container (prevents page jumping)
  const container = els.list; // this is the scrollable area
  const top = el.offsetTop - (container.clientHeight / 2) + (el.clientHeight / 2);

  container.scrollTo({
    top: Math.max(0, top),
    behavior: 'smooth'
  });
}


  function fitToMarkers(){
    const layers = cluster.getLayers();
    if(!layers.length) return;

    // If a few outliers are far outside the UK, they can blow up bounds and trigger a false warning.
    // So we fit to UK-ish points first, and only warn if most markers look non-UK.
    const within = [];
    let outsideCount = 0;

    for(const lyr of layers){
      if(!lyr || !lyr.getLatLng) continue;
      const ll = lyr.getLatLng();
      if(isWithinBounds(ll.lat, ll.lng, UK_SOFT_BOUNDS)){
        within.push(lyr);
      } else {
        outsideCount += 1;
      }
    }

    const total = within.length + outsideCount;

    // Nothing usable to fit
    if(!within.length){
      setStatus('warn', 'Loaded data, but none of the plotted coordinates look UK-based. Check your lat/lon columns (or rely on Location geocoding).');
      map.setView([54.5, -3.0], 6);
      return;
    }

    // Warn only if a majority look outside the UK (swapped coords / wrong units / bad geocodes).
    if(total && (outsideCount / total) > 0.5){
      setStatus('warn', 'Data loaded, but many marker coordinates look outside the UK. Check your lat/lon columns (or rely on Location geocoding).');
    }

    const group = L.featureGroup(within);
    const b = group.getBounds();
    map.fitBounds(b.pad(0.2));
  }


  function initYearSlider(minY, maxY){
    currentYearMin = minY;
    currentYearMax = maxY;

    if(els.yearSlider.noUiSlider){
      els.yearSlider.noUiSlider.destroy();
    }
    noUiSlider.create(els.yearSlider, {
      start: [minY, maxY],
      connect: true,
      step: 1,
      range: { min: minY, max: maxY },
      format: { to: v => Math.round(v), from: v => parseInt(v,10) }
    });
    els.yearMin.textContent = minY;
    els.yearMax.textContent = maxY;

    els.yearSlider.noUiSlider.on('update', (values) => {
      currentYearMin = parseInt(values[0],10);
      currentYearMax = parseInt(values[1],10);
      els.yearMin.textContent = currentYearMin;
      els.yearMax.textContent = currentYearMax;
      render();
    });
  }

  function populateRegionOptions(){
    const set = new Set(records.map(r => r.region).filter(Boolean));
    const regions = Array.from(set).sort();
    if(els.region){
      els.region.innerHTML = '<option value="">All</option>' + regions.map(r => `<option value="${escapeHtml(r)}">${escapeHtml(r)}</option>`).join('');
    }
}

  // Accept these coordinate headers:
  //  - lat/lon  (preferred)
  //  - Latitude/Longitude
  //  - Lat/Long  (your current sheet)
  function normaliseRow(r, idx){
    const latRaw = getField(r, ['lat','latitude','Lat','LAT']);
    const lonRaw = getField(r, ['lon','longitude','Long','LONG','lng','Lng']);

    const out = {
      id: idx,
      case: getField(r, ['Case','case']),
      date: getField(r, ['Date','date']),
      time: getField(r, ['Time','time']),
      date_iso: getField(r, ['Date_ISO','date_iso','Date ISO','Date (ISO)','ISO Date']),
      location: getField(r, ['Location','location']),
      region: getField(r, ['Region','region']),
      witness: getField(r, ['Witness profile','Witness','witness']),
      evidence: getField(r, ['Evidence','evidence']),
      summary: getField(r, ['Summary','summary']),
      status: getField(r, ['Status','status']),
      cred: Number(getField(r, ['Credibility (1-5)','Credibility','credibility']) || 0),
      why: getField(r, ['Why considered reputable','Why','why']),
      // Weather columns (support your new naming variations)
     weather: (() => {
  const w = String(getField(r, ['Weather','weather','Weather summary','Weather Summary','Historical weather','Historic weather','Weather (historic)','Weather (historical)']) || '').trim();
  // If it looks like a date/date-range, ignore it (prevents Date_ISO being shown as Weather)
  if (/^\d{4}-\d{2}(-\d{2})?(?:\s+to\s+\d{4}-\d{2}(-\d{2})?)?$/i.test(w)) return '';
  if (/^\d{1,2}\/\d{1,2}\/\d{4}(?:\s+to\s+\d{1,2}\/\d{1,2}\/\d{4})?$/i.test(w)) return '';
  return w;
})(),

      weather_source: getField(r, ['Weather source','weather source','Weather Source','Weather data source','Weather Data Source']),
      sources: getField(r, ['Sources','sources']),
      videos: getField(r, ['Videos','videos','Video','video','Video links','video links']),
      encounter: getField(r, ['Encounter','encounter']),
      year: safeYear(getField(r, ['Date_ISO','date_iso','Date','date'])),
      lat: Number(latRaw),
      lon: Number(lonRaw)
    };

    const fixed = normaliseCoords(out.lat, out.lon);
    out.lat = fixed.lat;
    out.lon = fixed.lon;

    return out;
  }

  // ==== Optional fallback geocoding (only if lat/lon missing) ====
  // Uses OpenStreetMap Nominatim. Please be considerate (rate-limited + cached).
  const GEO_CACHE_KEY = 'ufo_geo_cache_v1';
  const GEO_DELAY_MS = 1100; // ~1 req/sec
  const GEO_EMAIL = ''; // optional

  function loadGeoCache(){
    try { return JSON.parse(localStorage.getItem(GEO_CACHE_KEY) || '{}'); }
    catch { return {}; }
  }
  function saveGeoCache(cache){
    try { localStorage.setItem(GEO_CACHE_KEY, JSON.stringify(cache)); } catch {}
  }
  function cacheKeyForLocation(loc){
    return String(loc || '').trim().toLowerCase();
  }
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  async function geocodeLocation(loc){
    const q = String(loc || '').trim();
    if(!q) return null;

    const params = new URLSearchParams({ format: 'json', q, limit: '1', addressdetails: '0' });
    if (GEO_EMAIL) params.set('email', GEO_EMAIL);

    const url = 'https://nominatim.openstreetmap.org/search?' + params.toString();
    const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
    if(!res.ok) throw new Error('Geocoding HTTP ' + res.status);
    const data = await res.json();
    if(!Array.isArray(data) || !data.length) return null;

    const hit = data[0];
    const lat = Number(hit.lat);
    const lon = Number(hit.lon);
    if(!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
    return { lat, lon };
  }

  async function geocodeMissingCoords(){
    const cache = loadGeoCache();

    // Apply cache first
    for(const r of records){
      if(Number.isFinite(r.lat) && Number.isFinite(r.lon)) continue;
      const key = cacheKeyForLocation(r.location);
      if(key && cache[key]){
        r.lat = Number(cache[key].lat);
        r.lon = Number(cache[key].lon);
      }
    }

    const queue = records.filter(r => (!Number.isFinite(r.lat) || !Number.isFinite(r.lon)) && String(r.location || '').trim());
    if(!queue.length) return;

    setStatus('warn', `Geocoding ${queue.length} location(s)‚Ä¶ (cached where possible)`);
    setProgress(0, queue.length);

    let done = 0;
    for(const r of queue){
      try{
        const key = cacheKeyForLocation(r.location);
        if(key && cache[key]){
          r.lat = Number(cache[key].lat);
          r.lon = Number(cache[key].lon);
        } else {
          const got = await geocodeLocation(r.location);
          if(got){
            r.lat = got.lat;
            r.lon = got.lon;
            if(key) cache[key] = got;
            saveGeoCache(cache);
          }
          await sleep(GEO_DELAY_MS);
        }
      } catch(e){
        console.warn('Geocode failed for:', r.location, e);
        await sleep(GEO_DELAY_MS);
      } finally {
        done += 1;
        setProgress(done, queue.length);
        render();
      }
    }

    const stillMissing = records.filter(r => !Number.isFinite(r.lat) || !Number.isFinite(r.lon)).length;
    if(stillMissing){
      setStatus('warn', `Loaded ${records.length} rows. ${stillMissing} still missing lat/lon (won‚Äôt plot).`);
    } else {
      setStatus('ok', `Loaded ${records.length} rows. Ready.`);
    }
  }

  async function loadFromGoogleSheets(){
    setStatus('warn','Loading cases‚Ä¶');
    setProgress(0, 1);

    const url = SHEET_CSV_URL + (SHEET_CSV_URL.includes('?') ? '&' : '?') + 't=' + Date.now();

    return new Promise((resolve, reject) => {
      Papa.parse(url, {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: (results) => {
          const raw = Array.isArray(results.data) ? results.data : [];
          records = raw.map((row, idx) => normaliseRow(row, idx)).filter(r => (r.case || r.location || r.summary));
          els.kpiTotal.textContent = records.length;

          const years = records.map(r => r.year).filter(Boolean);
          const minY = years.length ? Math.min(...years) : 1950;
          const maxY = years.length ? Math.max(...years) : new Date().getFullYear();
          initYearSlider(minY, maxY);

          populateRegionOptions();

          // Default progress fill
          setProgress(1, 1);

          const missingCoords = records.filter(r => !Number.isFinite(r.lat) || !Number.isFinite(r.lon)).length;
          if(missingCoords){
            setStatus('warn', `Loaded ${records.length} rows. ${missingCoords} missing lat/lon (won't plot) ‚Äî using Location geocoding as a fallback.`);
          } else {
            setStatus('ok', `Loaded ${records.length} rows. Ready.`);
          }

          render();
          fitToMarkers();
          fixMapSizeSoon();

          // Fallback: geocode rows missing lat/lon (rate-limited + cached)
          geocodeMissingCoords().finally(() => resolve());
        },
        error: (err) => reject(err)
      });
    });
  }

  ['input','change'].forEach(evt => {
    if(els.search) els.search.addEventListener(evt, () => render());
    if(els.region) els.region.addEventListener(evt, () => render());
    if(els.minCred) els.minCred.addEventListener(evt, () => render());
    if(els.encounter) els.encounter.addEventListener(evt, () => render());
  });

  els.fitBtn.addEventListener('click', () => { fitToMarkers(); fixMapSizeSoon(); });
  els.resetBtn.addEventListener('click', () => {
    if(els.search) els.search.value = '';
    if(els.region) els.region.value = '';
    if(els.minCred) els.minCred.value = '3';
    if(els.encounter) els.encounter.value = '';
    const slider = els.yearSlider.noUiSlider;
    if(slider){
      const r = slider.options.range;
      slider.set([r.min, r.max]);
    }
    render();
    fitToMarkers();
  });


  // Layer toggles (airports / bases)
  function syncLayerToggles(){
    if(els.toggleAirports){
      if(els.toggleAirports.checked){
        airportsLayer.addTo(map);
      } else {
        map.removeLayer(airportsLayer);
      }
    }
    if(els.toggleBases){
      if(els.toggleBases.checked){
        basesLayer.addTo(map);
      } else {
        map.removeLayer(basesLayer);
      }
    }
  }

  if(els.toggleAirports) els.toggleAirports.addEventListener('change', syncLayerToggles);
  if(els.toggleBases) els.toggleBases.addEventListener('change', syncLayerToggles);

// Astro toggles / controls
if(els.toggleSat) els.toggleSat.addEventListener('change', () => { syncAstroToggles(); recalcAstroForSelected(); });
if(els.toggleMeteor) els.toggleMeteor.addEventListener('change', () => { syncAstroToggles(); recalcAstroForSelected(); });
if(els.satChoice) els.satChoice.addEventListener('change', () => { if(els.toggleSat && els.toggleSat.checked) recalcAstroForSelected(); });
if(els.recalcAstroBtn) els.recalcAstroBtn.addEventListener('click', () => recalcAstroForSelected());


  loadFromGoogleSheets().catch(err => {
    console.error(err);
    setStatus('bad', (err && err.message) ? err.message : String(err));
  });
})();
</script>

</body>
</html>